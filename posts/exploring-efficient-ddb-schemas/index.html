<!doctype html><html><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&display=swap" rel=stylesheet><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=/css/home.css type=text/css media=all><link rel=stylesheet href=/css/syntax.css type=text/css media=all><link disabled id=dark-mode-theme rel=stylesheet href=/css/dark.css><link rel=stylesheet href=https://use.fontawesome.com/releases/v5.7.2/css/all.css integrity=sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr crossorigin=anonymous><script defer language=javascript type=text/javascript src=/js/myscripts.js></script><html><head><title>Kelvin Koon</title>
<script src=https://use.fontawesome.com/b988afb9a9.js></script></head><link rel="shortcut icon" type=favicon href=/favicon.png></html><body><div class=dark-mode-toggle><p id=toggle class="fas fa-moon"></p></div><h1 class=home><a href=/>Kelvin Koon</a></h1><div class=sub-nav><table class=nav-items><td><a class=nav-item href=/posts>/blog</a>
<a class=nav-item href=/resume.pdf target=_blank>/resume</a>
<a class=nav-item href=https://github.com/kelvinkoon target=_blank>/github</a></td></table></div><div id=content><section id=main><h1><span class=header>Exploring Efficient DynamoDB Schemas</span></h1><p class=post-detail-date>Apr 16, 2023
· 7 min read</p><div class=post-tags>[
<a href=https://kelvinkoon.github.io/tags/statsugiri>statsugiri</a>
,
<a href=https://kelvinkoon.github.io/tags/aws>aws</a>
,
<a href=https://kelvinkoon.github.io/tags/backend>backend</a>
,
<a href=https://kelvinkoon.github.io/tags/project>project</a>
]</div><h2><span class=toc-header>Table of Contents</span></h2><div class=toc><nav id=TableOfContents><ul><li><a href=#serverless-simplicity>Serverless Simplicity</a></li><li><a href=#database-access-patterns>Database Access Patterns</a><ul><li><a href=#multiple-record-writes>Multiple Record Writes</a></li><li><a href=#client-side-filtering>Client-Side Filtering</a></li></ul></li><li><a href=#building-on-change-with-github-actions>Building on Change with Github Actions</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div><div><article id=content><p>Upon finishing the <a href=/posts/state-machines-pipelines-pokemon>PS ingestion</a> pipeline, next on the list was to implement a back-end as a means to serve the team data. Thus, this post discusses design considerations for the aforementioned <code>PsTeamsService</code>. You can try out the API <a href=https://api.statsugiri.gg/teams/gen9vgc2023regulationc/today>here</a>, complete with <a href=https://github.com/StatsugiriLabs/Statsugiri/wiki/PS-Teams-API-Usage>usage documentation</a>.</p><h2 id=serverless-simplicity>Serverless Simplicity</h2><p><figure><img src=/images/PsTeamsServiceArchitecture.png alt="PS Teams Service Architecture" loading=lazy><figcaption>PS Teams Service high-level design.</figcaption></figure></p><p>You can find a full-size image of the high-level design <a href=/images/PsTeamsServiceArchitecture.png>here</a>.</p><p>After some discussion, I opted for AWS Lambda and API Gateway to handle requests to the DynamoDB storage. Consideration was made for hosting the service on ECS Fargate, but the incurred additional cost and maintenance for compute didn&rsquo;t feel justified. Fewer resources also means fewer points of failure.</p><p>I ended up moving API Gateway to a separate CDK stack since it can be re-used to integrate with other services in the future. Deploying the stack is a time-consuming process since it also creates resources for associating the external domain. In particular, certificate validation via DNS takes time as does DNS propagation when associating a CNAME record with your external domain. The intended workflow is to deploy your service stack for console testing. When developers wish to test end-to-end, they can deploy the API Gateway stack after confirming their individual services are working as intended.</p><h2 id=database-access-patterns>Database Access Patterns</h2><p>For the current iteration, there were two primary use-cases.</p><ul><li>Retrieving teams from a date (ie. &ldquo;snapshot date&rdquo;)</li><li>Filtering teams by certain Pokémon<ul><li>eg. return all teams with Arcanine and Palafin</li></ul></li></ul><p>I structured the API endpoints so clients were required to provide both a format and date. This allowed me to create a composite key to act as the sort key (eg. <code>gen9vgc2023regulationc#2023-04-11</code>). In addition, a global secondary index (GSI) was added to the composite key for querying. Thus, the first use-case is fulfilled through this schema design.</p><p>The second use-case is a bit more interesting in how it can be tackled. Let&rsquo;s take a look at two options.</p><h3 id=multiple-record-writes>Multiple Record Writes</h3><p>Credits to my coworker, Daniel, for suggesting the design.</p><p>To efficiently filter by a Pokémon, the DynamoDB data producer can write each individual Pokémon per team as the sort key as its own record under the same primary key. The sort key can be a flexible field for serving either the Pokémon on the team or other metadata (eg. DynamoDB item type).</p><pre tabindex=0><code>| primary_key | sort_key (gsi) |
| ----------- | -------------- |
| 1000        | team           |
| 1000        | amoonguss      |
| 1000        | arcanine       |
| 1000        | flutter mane   |
| 1000        | great tusk     |
| 1000        | iron bundle    |
| 1000        | ting-lu        |
</code></pre><p>Putting a GSI on the sort key lets DynamoDB do the heavy lifting for you. The sort key can be a composite key with the snapshot date (eg. <code>amoonguss#2023-04-14</code>) to make queries easier.</p><p>Unfortunately, the design falls short when filtering for multiple Pokémon. Every Pokémon the client filters for is an additional query. In addition, every team requires up to 6 additional writes for each Pokémon in the team.<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> The multiple item writes is a clever design for efficient reads when you have a set of items as an alternative to forcing a GSI onto the column.</p><h3 id=client-side-filtering>Client-Side Filtering</h3><p>Client-side filtering was the accepted choice given the payload size. With each query being relatively small (100 items at most, each item less than 400 bytes), client-side filtering isn&rsquo;t too costly from a performance standpoint. Even when filtering for multiple Pokémon, the performance has a comparable latency<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> to filtering for a single Pokémon.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><pre tabindex=0><code>| team_id(pk) | composite (gsi+sk)   | pkmn_team                      |
| ----------- | -------------------- | ------------------------------ |
| 1000        | vgcformat#2023-04-14 | [&#34;amoonguss&#34;, &#34;arcanine&#34;, ...] |
| 1001        | vgcformat#2023-04-14 | [&#34;chi-yu&#34;, &#34;great tusk&#34;, ...]  |
| 1002        | vgcformat#2023-04-15 | [&#34;chien-pao&#34;, &#34;dondozo&#34;, ...]  |
</code></pre><h2 id=building-on-change-with-github-actions>Building on Change with Github Actions</h2><p>Previously, Github Actions would build and push Docker images to Elastic Container Registry (ECR) from every service when a pull request was merged. As a result, every merge cluttered the ECR repos with superfluous images, making it difficult to discern images during deployment. Additional costs were also incurring with every commit.</p><p>I previously investigated solving this with Github Actions&rsquo;s <a href=https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore>paths</a> filter. The paths filter can detect changes and run workflows based on file changes, such as building the ingestion pipeline image only when changes were made to the directory. Simple solution, right?</p><p>Unfortunately, I encountered many hurdles with this configuration. In fact, this <a href=https://stackoverflow.com/questions/71352117/running-a-github-actions-workflow-only-on-events-in-a-pull-request-events-that-c>Stack Overflow post</a> seems to corroborate my experience where it isn&rsquo;t possible at the workflow level. Coincidentally, I stumbled upon this <a href=https://dev.to/po5i/github-action-to-run-mypy-on-changed-files-only-3iip>post</a> on integrating the <code>changed-files</code> action, which is the same action suggested in the Stack Overflow post. My <a href=https://github.com/StatsugiriLabs/Statsugiri/blob/master/.github/workflows/on-merge-ps-ingestion-pipeline.yml#L30-L45>workflow</a> is similar, though it checks only for Python file changes within each directory. The production code doesn&rsquo;t depend on other file types (eg. <code>.txt</code>, <code>.json</code>) outside of tests, though that may change in the future. After a few dummy commits to test the workflow, I was happy to confirm it was Spring Cleaning for ECR.</p><h2 id=conclusion>Conclusion</h2><p>Though a relatively simple service, migrating to AWS / CDK has been a massive quality-of-life improvement for deployments and monitoring (ie. alarms and dashboards). With a backend deployed to prod, all that&rsquo;s left for an official launch is the UI. If you enjoyed this write-up, please consider supporting the project through <a href=https://ko-fi.com/statsugiri>Ko-Fi</a> or <a href=https://github.com/sponsors/kelvinkoon>Github Sponsors</a>.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Pokémon Showdown enforces a minimum of 4 Pokémon per team, so every record has, at minimum, an additional 4 writes. That being said, most teams will have 6 Pokémon for competitive advantage.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Given it&rsquo;s a personal project, my tolerance for &ldquo;acceptable&rdquo; is anything less than a second. Certainly an unambitious bar, but an unnecessary worry until customers see a noticeable difference. Refer to my <a href=https://kelvinkoon.dev/posts/building-babiri-net/#caching>caching write-up</a> for more thoughts.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Brief curl benchmarking showed about 130-150ms for both queries. Again, these seem like decent numbers until they aren&rsquo;t.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></div></section><p><a class=menu-item href=/posts>← return to blog</a></p><hr></div><p class=copyright>made with hugo, © 2025</p><p class=footer-links><a class=source href=https://github.com/kelvinkoon/kelvinkoon.dev target=_blank>source</a>
<a class=instagram href=http://instagram.com/notcelsiusdeg target=_blank>instagram</a></p></body></html>